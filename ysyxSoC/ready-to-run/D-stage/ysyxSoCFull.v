// Generated by CIRCT firtool-1.105.0

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module AXI4Xbar(
  input         clock,
                reset,
  output        auto_anon_in_awready,
  input         auto_anon_in_awvalid,
  input  [31:0] auto_anon_in_awaddr,
  input  [2:0]  auto_anon_in_awsize,
  output        auto_anon_in_wready,
  input         auto_anon_in_wvalid,
  input  [31:0] auto_anon_in_wdata,
  input  [3:0]  auto_anon_in_wstrb,
  input         auto_anon_in_bready,
  output        auto_anon_in_bvalid,
                auto_anon_in_arready,
  input         auto_anon_in_arvalid,
  input  [31:0] auto_anon_in_araddr,
  input  [2:0]  auto_anon_in_arsize,
  input         auto_anon_in_rready,
  output        auto_anon_in_rvalid,
  output [31:0] auto_anon_in_rdata,
  input         auto_anon_out_awready,
  output        auto_anon_out_awvalid,
  output [31:0] auto_anon_out_awaddr,
  output [2:0]  auto_anon_out_awsize,
  input         auto_anon_out_wready,
  output        auto_anon_out_wvalid,
  output [31:0] auto_anon_out_wdata,
  output [3:0]  auto_anon_out_wstrb,
  output        auto_anon_out_bready,
  input         auto_anon_out_bvalid,
                auto_anon_out_arready,
  output        auto_anon_out_arvalid,
  output [31:0] auto_anon_out_araddr,
  output [2:0]  auto_anon_out_arsize,
  output        auto_anon_out_rready,
  input         auto_anon_out_rvalid,
  input  [31:0] auto_anon_out_rdata
);

  assign auto_anon_in_awready = auto_anon_out_awready;
  assign auto_anon_in_wready = auto_anon_out_wready;
  assign auto_anon_in_bvalid = auto_anon_out_bvalid;
  assign auto_anon_in_arready = auto_anon_out_arready;
  assign auto_anon_in_rvalid = auto_anon_out_rvalid;
  assign auto_anon_in_rdata = auto_anon_out_rdata;
  assign auto_anon_out_awvalid = auto_anon_in_awvalid;
  assign auto_anon_out_awaddr = auto_anon_in_awaddr;
  assign auto_anon_out_awsize = auto_anon_in_awsize;
  assign auto_anon_out_wvalid = auto_anon_in_wvalid;
  assign auto_anon_out_wdata = auto_anon_in_wdata;
  assign auto_anon_out_wstrb = auto_anon_in_wstrb;
  assign auto_anon_out_bready = auto_anon_in_bready;
  assign auto_anon_out_arvalid = auto_anon_in_arvalid;
  assign auto_anon_out_araddr = auto_anon_in_araddr;
  assign auto_anon_out_arsize = auto_anon_in_arsize;
  assign auto_anon_out_rready = auto_anon_in_rready;
endmodule

module APBFanout(
  input         auto_anon_in_psel,
                auto_anon_in_penable,
                auto_anon_in_pwrite,
  input  [31:0] auto_anon_in_paddr,
  input  [2:0]  auto_anon_in_pprot,
  input  [31:0] auto_anon_in_pwdata,
  input  [3:0]  auto_anon_in_pstrb,
  output        auto_anon_in_pready,
                auto_anon_in_pslverr,
  output [31:0] auto_anon_in_prdata,
  output        auto_anon_out_2_psel,
                auto_anon_out_2_penable,
                auto_anon_out_2_pwrite,
  output [31:0] auto_anon_out_2_paddr,
  output [2:0]  auto_anon_out_2_pprot,
  output [31:0] auto_anon_out_2_pwdata,
  output [3:0]  auto_anon_out_2_pstrb,
  input         auto_anon_out_2_pready,
                auto_anon_out_2_pslverr,
  input  [31:0] auto_anon_out_2_prdata,
  output        auto_anon_out_1_psel,
                auto_anon_out_1_penable,
                auto_anon_out_1_pwrite,
  output [28:0] auto_anon_out_1_paddr,
  output [2:0]  auto_anon_out_1_pprot,
  output [31:0] auto_anon_out_1_pwdata,
  output [3:0]  auto_anon_out_1_pstrb,
  input         auto_anon_out_1_pready,
                auto_anon_out_1_pslverr,
  input  [31:0] auto_anon_out_1_prdata,
  output        auto_anon_out_0_psel,
                auto_anon_out_0_penable,
                auto_anon_out_0_pwrite,
  output [29:0] auto_anon_out_0_paddr,
  output [2:0]  auto_anon_out_0_pprot,
  output [31:0] auto_anon_out_0_pwdata,
  output [3:0]  auto_anon_out_0_pstrb,
  input         auto_anon_out_0_pready,
  input  [31:0] auto_anon_out_0_prdata
);

  wire sel_0 =
    {auto_anon_in_paddr[31], auto_anon_in_paddr[29], ~(auto_anon_in_paddr[12])} == 3'h0
    | {auto_anon_in_paddr[31], ~(auto_anon_in_paddr[29])} == 2'h0;
  wire sel_1 =
    {auto_anon_in_paddr[31], auto_anon_in_paddr[29], auto_anon_in_paddr[12]} == 3'h0;
  wire sel_2 = {~(auto_anon_in_paddr[31]), auto_anon_in_paddr[29]} == 2'h0;
  assign auto_anon_in_pready =
    ~(sel_0 & ~auto_anon_out_0_pready | sel_1 & ~auto_anon_out_1_pready | sel_2
      & ~auto_anon_out_2_pready);
  assign auto_anon_in_pslverr =
    sel_1 & auto_anon_out_1_pslverr | sel_2 & auto_anon_out_2_pslverr;
  assign auto_anon_in_prdata =
    (sel_0 ? auto_anon_out_0_prdata : 32'h0) | (sel_1 ? auto_anon_out_1_prdata : 32'h0)
    | (sel_2 ? auto_anon_out_2_prdata : 32'h0);
  assign auto_anon_out_2_psel = sel_2 & auto_anon_in_psel;
  assign auto_anon_out_2_penable = sel_2 & auto_anon_in_penable;
  assign auto_anon_out_2_pwrite = auto_anon_in_pwrite;
  assign auto_anon_out_2_paddr = auto_anon_in_paddr;
  assign auto_anon_out_2_pprot = auto_anon_in_pprot;
  assign auto_anon_out_2_pwdata = auto_anon_in_pwdata;
  assign auto_anon_out_2_pstrb = auto_anon_in_pstrb;
  assign auto_anon_out_1_psel = sel_1 & auto_anon_in_psel;
  assign auto_anon_out_1_penable = sel_1 & auto_anon_in_penable;
  assign auto_anon_out_1_pwrite = auto_anon_in_pwrite;
  assign auto_anon_out_1_paddr = auto_anon_in_paddr[28:0];
  assign auto_anon_out_1_pprot = auto_anon_in_pprot;
  assign auto_anon_out_1_pwdata = auto_anon_in_pwdata;
  assign auto_anon_out_1_pstrb = auto_anon_in_pstrb;
  assign auto_anon_out_0_psel = sel_0 & auto_anon_in_psel;
  assign auto_anon_out_0_penable = sel_0 & auto_anon_in_penable;
  assign auto_anon_out_0_pwrite = auto_anon_in_pwrite;
  assign auto_anon_out_0_paddr = auto_anon_in_paddr[29:0];
  assign auto_anon_out_0_pprot = auto_anon_in_pprot;
  assign auto_anon_out_0_pwdata = auto_anon_in_pwdata;
  assign auto_anon_out_0_pstrb = auto_anon_in_pstrb;
endmodule


// Include register initializers in init blocks unless synthesis is set
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Standard header to adapt well known macros for register randomization.

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_
module MemBridge(
  input         clock,
                reset,
  input  [31:0] io_ifu_addr,
  input         io_ifu_reqValid,
  output [31:0] io_ifu_rdata,
  output        io_ifu_respValid,
  input  [31:0] io_lsu_addr,
  input         io_lsu_reqValid,
  output [31:0] io_lsu_rdata,
  output        io_lsu_respValid,
  input  [1:0]  io_lsu_size,
  input         io_lsu_wen,
  input  [31:0] io_lsu_wdata,
  input  [3:0]  io_lsu_wmask,
  input         io_out_awready,
  output        io_out_awvalid,
  output [31:0] io_out_awaddr,
  output [2:0]  io_out_awsize,
  input         io_out_wready,
  output        io_out_wvalid,
  output [31:0] io_out_wdata,
  output [3:0]  io_out_wstrb,
  output        io_out_bready,
  input         io_out_bvalid,
                io_out_arready,
  output        io_out_arvalid,
  output [31:0] io_out_araddr,
  output [2:0]  io_out_arsize,
  output        io_out_rready,
  input         io_out_rvalid,
  input  [31:0] io_out_rdata
);

  wire        isValidLoad = io_lsu_reqValid & ~io_lsu_wen;
  wire        isValidStore = io_lsu_reqValid & io_lsu_wen;
  reg  [1:0]  stateI;
  wire        _io_out_arvalid_T = stateI == 2'h0;
  wire        _io_out_arvalid_T_2 = stateI == 2'h1;
  wire        _instReturn_T = stateI == 2'h2;
  reg  [2:0]  stateD;
  wire        _io_out_wvalid_T = stateD == 3'h0;
  wire        _lsuRead_T_2 = stateD == 3'h1;
  wire        _io_lsu_respValid_T = stateD == 3'h2;
  wire        _io_out_awvalid_T_2 = stateD == 3'h3;
  wire        _io_out_awvalid_T_3 = stateD == 3'h5;
  wire        _io_out_wvalid_T_2 = stateD == 3'h4;
  wire        io_out_bready_0 = stateD == 3'h6;
  wire        lsuRead = _io_out_wvalid_T & isValidLoad | _lsuRead_T_2;
  wire        instReturn = io_out_rvalid & _instReturn_T;
  reg  [31:0] io_ifu_rdata_r;
  always @(posedge clock) begin
    if (reset) begin
      stateI <= 2'h0;
      stateD <= 3'h0;
    end
    else begin
      automatic logic [1:0] _stateD_T_22 = io_out_arready ? 2'h2 : 2'h1;
      automatic logic [1:0] _stateD_T_24 = {~io_out_rvalid, 1'h0};
      automatic logic [2:0] _stateD_T_30 = {1'h1, io_out_wready, 1'h0};
      automatic logic [2:0] _stateD_T_21 =
        _io_out_wvalid_T
          ? (isValidLoad
               ? {1'h0, _stateD_T_22}
               : isValidStore
                   ? (io_out_awready ? _stateD_T_30 : io_out_wready ? 3'h5 : 3'h3)
                   : 3'h0)
          : 3'h0;
      stateI <=
        (_io_out_arvalid_T & io_ifu_reqValid | _io_out_arvalid_T_2
           ? _stateD_T_22
           : 2'h0) | (_instReturn_T ? _stateD_T_24 : 2'h0);
      stateD <=
        {_stateD_T_21[2],
         _stateD_T_21[1:0] | (_lsuRead_T_2 ? _stateD_T_22 : 2'h0)
           | (_io_lsu_respValid_T ? _stateD_T_24 : 2'h0)}
        | (_io_out_awvalid_T_2 ? (io_out_awready ? _stateD_T_30 : 3'h3) : 3'h0)
        | (_io_out_awvalid_T_3 ? (io_out_awready ? 3'h6 : 3'h5) : 3'h0)
        | (_io_out_wvalid_T_2 ? _stateD_T_30 : 3'h0)
        | (~io_out_bready_0 | io_out_bvalid ? 3'h0 : 3'h6);
    end
    if (instReturn)
      io_ifu_rdata_r <= io_out_rdata;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    initial begin
      automatic logic [31:0] _RANDOM[0:1];
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [1:0] i = 2'h0; i < 2'h2; i += 2'h1) begin
          _RANDOM[i[0]] = `RANDOM;
        end
        stateI = _RANDOM[1'h0][1:0];
        stateD = _RANDOM[1'h0][4:2];
        io_ifu_rdata_r = {_RANDOM[1'h0][31:5], _RANDOM[1'h1][4:0]};
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_ifu_rdata = instReturn ? io_out_rdata : io_ifu_rdata_r;
  assign io_ifu_respValid = instReturn;
  assign io_lsu_rdata = io_out_rdata;
  assign io_lsu_respValid =
    _io_lsu_respValid_T & io_out_rvalid | io_out_bready_0 & io_out_bvalid;
  assign io_out_awvalid =
    |{_io_out_wvalid_T & isValidStore, _io_out_awvalid_T_3, _io_out_awvalid_T_2};
  assign io_out_awaddr = io_lsu_addr;
  assign io_out_awsize = {1'h0, io_lsu_size};
  assign io_out_wvalid = _io_out_wvalid_T & isValidStore | _io_out_wvalid_T_2;
  assign io_out_wdata = io_lsu_wdata;
  assign io_out_wstrb = io_lsu_wmask;
  assign io_out_bready = io_out_bready_0;
  assign io_out_arvalid =
    _io_out_arvalid_T & io_ifu_reqValid | _io_out_arvalid_T_2 | lsuRead;
  assign io_out_araddr = lsuRead ? io_lsu_addr : io_ifu_addr;
  assign io_out_arsize = {1'h0, lsuRead ? io_lsu_size : 2'h2};
  assign io_out_rready = _instReturn_T | _io_lsu_respValid_T;
endmodule

module CPU(
  input         clock,
                reset,
                auto_master_out_awready,
  output        auto_master_out_awvalid,
  output [31:0] auto_master_out_awaddr,
  output [2:0]  auto_master_out_awsize,
  input         auto_master_out_wready,
  output        auto_master_out_wvalid,
  output [31:0] auto_master_out_wdata,
  output [3:0]  auto_master_out_wstrb,
  output        auto_master_out_bready,
  input         auto_master_out_bvalid,
                auto_master_out_arready,
  output        auto_master_out_arvalid,
  output [31:0] auto_master_out_araddr,
  output [2:0]  auto_master_out_arsize,
  output        auto_master_out_rready,
  input         auto_master_out_rvalid,
  input  [31:0] auto_master_out_rdata
);

  wire [31:0] _bridge_io_ifu_rdata;
  wire        _bridge_io_ifu_respValid;
  wire [31:0] _bridge_io_lsu_rdata;
  wire        _bridge_io_lsu_respValid;
  wire [31:0] _cpu_io_ifu_addr;
  wire        _cpu_io_ifu_reqValid;
  wire [31:0] _cpu_io_lsu_addr;
  wire        _cpu_io_lsu_reqValid;
  wire [1:0]  _cpu_io_lsu_size;
  wire        _cpu_io_lsu_wen;
  wire [31:0] _cpu_io_lsu_wdata;
  wire [3:0]  _cpu_io_lsu_wmask;
  ysyx_00000000 cpu (
    .clock            (clock),
    .reset            (reset),
    .io_ifu_addr      (_cpu_io_ifu_addr),
    .io_ifu_reqValid  (_cpu_io_ifu_reqValid),
    .io_ifu_rdata     (_bridge_io_ifu_rdata),
    .io_ifu_respValid (_bridge_io_ifu_respValid),
    .io_lsu_addr      (_cpu_io_lsu_addr),
    .io_lsu_reqValid  (_cpu_io_lsu_reqValid),
    .io_lsu_rdata     (_bridge_io_lsu_rdata),
    .io_lsu_respValid (_bridge_io_lsu_respValid),
    .io_lsu_size      (_cpu_io_lsu_size),
    .io_lsu_wen       (_cpu_io_lsu_wen),
    .io_lsu_wdata     (_cpu_io_lsu_wdata),
    .io_lsu_wmask     (_cpu_io_lsu_wmask)
  );
  MemBridge bridge (
    .clock               (clock),
    .reset               (reset),
    .io_ifu_addr         (_cpu_io_ifu_addr),
    .io_ifu_reqValid     (_cpu_io_ifu_reqValid),
    .io_ifu_rdata        (_bridge_io_ifu_rdata),
    .io_ifu_respValid    (_bridge_io_ifu_respValid),
    .io_lsu_addr         (_cpu_io_lsu_addr),
    .io_lsu_reqValid     (_cpu_io_lsu_reqValid),
    .io_lsu_rdata        (_bridge_io_lsu_rdata),
    .io_lsu_respValid    (_bridge_io_lsu_respValid),
    .io_lsu_size         (_cpu_io_lsu_size),
    .io_lsu_wen          (_cpu_io_lsu_wen),
    .io_lsu_wdata        (_cpu_io_lsu_wdata),
    .io_lsu_wmask        (_cpu_io_lsu_wmask),
    .io_out_awready     (auto_master_out_awready),
    .io_out_awvalid     (auto_master_out_awvalid),
    .io_out_awaddr (auto_master_out_awaddr),
    .io_out_awsize (auto_master_out_awsize),
    .io_out_wready      (auto_master_out_wready),
    .io_out_wvalid      (auto_master_out_wvalid),
    .io_out_wdata  (auto_master_out_wdata),
    .io_out_wstrb  (auto_master_out_wstrb),
    .io_out_bready      (auto_master_out_bready),
    .io_out_bvalid      (auto_master_out_bvalid),
    .io_out_arready     (auto_master_out_arready),
    .io_out_arvalid     (auto_master_out_arvalid),
    .io_out_araddr (auto_master_out_araddr),
    .io_out_arsize (auto_master_out_arsize),
    .io_out_rready      (auto_master_out_rready),
    .io_out_rvalid      (auto_master_out_rvalid),
    .io_out_rdata  (auto_master_out_rdata)
  );
endmodule

module APBUart16550(
  input         clock,
                reset,
                auto_in_psel,
                auto_in_penable,
                auto_in_pwrite,
  input  [28:0] auto_in_paddr,
  input  [2:0]  auto_in_pprot,
  input  [31:0] auto_in_pwdata,
  input  [3:0]  auto_in_pstrb,
  output        auto_in_pready,
                auto_in_pslverr,
  output [31:0] auto_in_prdata,
  input         uart_rx,
  output        uart_tx
);

  uart_top_apb muart (
    .clock      (clock),
    .reset      (reset),
    .in_psel    (auto_in_psel),
    .in_penable (auto_in_penable),
    .in_pwrite  (auto_in_pwrite),
    .in_paddr   ({3'h0, auto_in_paddr}),
    .in_pprot   (auto_in_pprot),
    .in_pwdata  (auto_in_pwdata),
    .in_pstrb   (auto_in_pstrb),
    .in_pready  (auto_in_pready),
    .in_pslverr (auto_in_pslverr),
    .in_prdata  (auto_in_prdata),
    .uart_rx    (uart_rx),
    .uart_tx    (uart_tx)
  );
endmodule

module APBSPI(
  input         clock,
                reset,
                auto_in_psel,
                auto_in_penable,
                auto_in_pwrite,
  input  [29:0] auto_in_paddr,
  input  [2:0]  auto_in_pprot,
  input  [31:0] auto_in_pwdata,
  input  [3:0]  auto_in_pstrb,
  output        auto_in_pready,
  output [31:0] auto_in_prdata,
  output        spi_bundle_sck,
  output [7:0]  spi_bundle_ss,
  output        spi_bundle_mosi,
  input         spi_bundle_miso
);

  wire        _mspi_in_pready;
  wire [31:0] _mspi_in_prdata;
  wire        _mspi_spi_irq_out;
  reg  [3:0]  cmd_state;
  reg  [1:0]  spi_state;
  wire        mspi_in_psel = spi_state == 2'h2;
  wire        spi_ack = mspi_in_psel & _mspi_in_pready;
  wire        _mspi_io_in_paddr_T_11 = cmd_state == 4'h8;
  wire        _mspi_io_in_pstrb_T = cmd_state == 4'h1;
  wire        _mspi_io_in_pwdata_T_3 = cmd_state == 4'h2;
  wire        _mspi_io_in_pwdata_T_5 = cmd_state == 4'h3;
  wire        _mspi_io_in_pwdata_T_7 = cmd_state == 4'h4;
  wire        _mspi_io_in_pwdata_T_9 = cmd_state == 4'h5;
  wire        _mspi_io_in_pwdata_T_11 = cmd_state == 4'h6;
  always @(posedge clock) begin
    if (reset) begin
      cmd_state <= 4'h0;
      spi_state <= 2'h0;
    end
    else begin
      if (cmd_state == 4'h0) begin
        if (auto_in_psel & auto_in_penable)
          cmd_state <= auto_in_paddr > 30'h2FFFFFFF & ~auto_in_pwrite ? 4'h2 : 4'h1;
      end
      else if (cmd_state == 4'h1) begin
        if (spi_ack)
          cmd_state <= 4'h0;
      end
      else if (cmd_state == 4'h2) begin
        if (spi_ack)
          cmd_state <= 4'h3;
      end
      else if (cmd_state == 4'h3) begin
        if (spi_ack)
          cmd_state <= 4'h4;
      end
      else if (cmd_state == 4'h4) begin
        if (spi_ack)
          cmd_state <= 4'h5;
      end
      else if (cmd_state == 4'h5) begin
        if (spi_ack)
          cmd_state <= 4'h6;
      end
      else if (cmd_state == 4'h6) begin
        if (spi_ack)
          cmd_state <= 4'h7;
      end
      else if (cmd_state == 4'h7) begin
        if (_mspi_spi_irq_out)
          cmd_state <= 4'h8;
      end
      else if (cmd_state == 4'h8 & spi_ack)
        cmd_state <= 4'h0;
      if (spi_state == 2'h0) begin
        if ((|cmd_state) & cmd_state != 4'h7)
          spi_state <= 2'h1;
      end
      else if (spi_state == 2'h1)
        spi_state <= 2'h2;
      else if (mspi_in_psel & _mspi_in_pready)
        spi_state <= 2'h0;
    end
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    initial begin
      automatic logic [31:0] _RANDOM[0:0];
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        cmd_state = _RANDOM[/*Zero width*/ 1'b0][3:0];
        spi_state = _RANDOM[/*Zero width*/ 1'b0][5:4];
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  spi_top_apb mspi (
    .clock       (clock),
    .reset       (reset),
    .in_psel     (mspi_in_psel),
    .in_penable  (spi_state == 2'h1 | mspi_in_psel),
    .in_pwrite   (_mspi_io_in_pstrb_T ? auto_in_pwrite : cmd_state != 4'h8),
    .in_paddr
      ({27'h0,
        _mspi_io_in_paddr_T_11
          ? 3'h0
          : _mspi_io_in_pwdata_T_11
              ? 3'h4
              : _mspi_io_in_pwdata_T_9
                  ? 3'h6
                  : _mspi_io_in_pwdata_T_7
                      ? 3'h5
                      : _mspi_io_in_pwdata_T_5
                          ? 3'h1
                          : _mspi_io_in_pwdata_T_3 ? 3'h0 : auto_in_paddr[4:2],
        2'h0}),
    .in_pprot    (auto_in_pprot),
    .in_pwdata
      (_mspi_io_in_pwdata_T_11
         ? 32'h3540
         : _mspi_io_in_pwdata_T_9
             ? 32'h1
             : _mspi_io_in_pwdata_T_7
                 ? 32'h0
                 : _mspi_io_in_pwdata_T_5
                     ? {8'h3, auto_in_paddr[23:2], 2'h0}
                     : _mspi_io_in_pwdata_T_3 ? 32'h0 : auto_in_pwdata),
    .in_pstrb    (_mspi_io_in_pstrb_T ? auto_in_pstrb : 4'hF),
    .in_pready   (_mspi_in_pready),
    .in_pslverr  (/* unused */),
    .in_prdata   (_mspi_in_prdata),
    .spi_sck     (spi_bundle_sck),
    .spi_ss      (spi_bundle_ss),
    .spi_mosi    (spi_bundle_mosi),
    .spi_miso    (spi_bundle_miso),
    .spi_irq_out (_mspi_spi_irq_out)
  );
  assign auto_in_pready = (_mspi_io_in_pstrb_T | _mspi_io_in_paddr_T_11) & spi_ack;
  assign auto_in_prdata =
    _mspi_io_in_paddr_T_11
      ? {_mspi_in_prdata[7:0],
         _mspi_in_prdata[15:8],
         _mspi_in_prdata[23:16],
         _mspi_in_prdata[31:24]}
      : _mspi_in_prdata;
endmodule

module APBSDRAM(
  input         clock,
                reset,
                auto_in_psel,
                auto_in_penable,
                auto_in_pwrite,
  input  [31:0] auto_in_paddr,
  input  [2:0]  auto_in_pprot,
  input  [31:0] auto_in_pwdata,
  input  [3:0]  auto_in_pstrb,
  output        auto_in_pready,
                auto_in_pslverr,
  output [31:0] auto_in_prdata,
  output        sdram_bundle_clk,
                sdram_bundle_cke,
                sdram_bundle_cs,
                sdram_bundle_ras,
                sdram_bundle_cas,
                sdram_bundle_we,
  output [12:0] sdram_bundle_a,
  output [1:0]  sdram_bundle_ba,
                sdram_bundle_dqm,
  inout  [15:0] sdram_bundle_dq
);

  sdram_top_apb msdram (
    .clock      (clock),
    .reset      (reset),
    .in_psel    (auto_in_psel),
    .in_penable (auto_in_penable),
    .in_pwrite  (auto_in_pwrite),
    .in_paddr   (auto_in_paddr),
    .in_pprot   (auto_in_pprot),
    .in_pwdata  (auto_in_pwdata),
    .in_pstrb   (auto_in_pstrb),
    .in_pready  (auto_in_pready),
    .in_pslverr (auto_in_pslverr),
    .in_prdata  (auto_in_prdata),
    .sdram_clk  (sdram_bundle_clk),
    .sdram_cke  (sdram_bundle_cke),
    .sdram_cs   (sdram_bundle_cs),
    .sdram_ras  (sdram_bundle_ras),
    .sdram_cas  (sdram_bundle_cas),
    .sdram_we   (sdram_bundle_we),
    .sdram_a    (sdram_bundle_a),
    .sdram_ba   (sdram_bundle_ba),
    .sdram_dqm  (sdram_bundle_dqm),
    .sdram_dq   (sdram_bundle_dq)
  );
endmodule

module AXI4ToAPB(
  input         clock,
                reset,
  output        auto_in_awready,
  input         auto_in_awvalid,
  input  [31:0] auto_in_awaddr,
  input  [7:0]  auto_in_awlen,
  input  [2:0]  auto_in_awsize,
  output        auto_in_wready,
  input         auto_in_wvalid,
  input  [31:0] auto_in_wdata,
  input  [3:0]  auto_in_wstrb,
  input         auto_in_bready,
  output        auto_in_bvalid,
                auto_in_arready,
  input         auto_in_arvalid,
  input  [3:0]  auto_in_arid,
  input  [31:0] auto_in_araddr,
  input  [7:0]  auto_in_arlen,
  input  [2:0]  auto_in_arsize,
  input         auto_in_rready,
  output        auto_in_rvalid,
  output [3:0]  auto_in_rid,
  output [31:0] auto_in_rdata,
  output [1:0]  auto_in_rresp,
  output        auto_out_psel,
                auto_out_penable,
                auto_out_pwrite,
  output [31:0] auto_out_paddr,
                auto_out_pwdata,
  output [3:0]  auto_out_pstrb,
  input         auto_out_pready,
                auto_out_pslverr,
  input  [31:0] auto_out_prdata
);

  wire        nodeOut_penable;
  reg  [1:0]  state;
  wire        _is_write_T = state == 2'h0;
  wire        accept_read = _is_write_T & auto_in_arvalid;
  wire        accept_write =
    ~accept_read & _is_write_T & auto_in_awvalid & auto_in_wvalid;
  reg         is_write_r;
  wire        is_write = _is_write_T ? accept_write : is_write_r;
  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset & auto_in_arvalid & (|auto_in_arlen)) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at AXI4ToAPB.scala:61\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & auto_in_awvalid & (|auto_in_awlen)) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at AXI4ToAPB.scala:62\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & auto_in_arvalid & auto_in_arsize > 3'h2) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at AXI4ToAPB.scala:64\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & auto_in_awvalid & auto_in_awsize > 3'h2) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at AXI4ToAPB.scala:65\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
  reg  [3:0]  rid_reg;
  reg  [31:0] araddr_reg_r;
  reg  [31:0] awaddr_reg_r;
  reg  [31:0] wdata_reg_r;
  reg  [3:0]  wstrb_reg_r;
  assign nodeOut_penable = state == 2'h1;
  wire [1:0]  resp = {auto_out_pslverr, 1'h0};
  reg  [1:0]  resp_hold_r;
  wire        _nodeIn_bvalid_T_2 = state == 2'h2;
  wire        nodeIn_rvalid =
    ~is_write & (nodeOut_penable & auto_out_pready | _nodeIn_bvalid_T_2);
  reg  [31:0] nodeIn_rdata_r;
  wire        nodeIn_bvalid =
    is_write & (nodeOut_penable & auto_out_pready | _nodeIn_bvalid_T_2);
  always @(posedge clock) begin
    if (reset)
      state <= 2'h0;
    else begin
      automatic logic [3:0][1:0] _GEN;
      _GEN =
        {{state},
         {{~(auto_in_rready & nodeIn_rvalid | auto_in_bready & nodeIn_bvalid), 1'h0}},
         {auto_out_pready
            ? {~(auto_in_rready & nodeIn_rvalid | auto_in_bready & nodeIn_bvalid),
               1'h0}
            : 2'h1},
         {{1'h0, auto_in_arvalid | auto_in_awvalid & auto_in_wvalid}}};
      state <= _GEN[state];
    end
    if (_is_write_T)
      is_write_r <= accept_write;
    if (accept_read) begin
      rid_reg <= auto_in_arid;
      araddr_reg_r <= auto_in_araddr;
    end
    if (accept_write) begin
      awaddr_reg_r <= auto_in_awaddr;
      wdata_reg_r <= auto_in_wdata;
      wstrb_reg_r <= auto_in_wstrb;
    end
    if (nodeOut_penable) begin
      resp_hold_r <= resp;
      nodeIn_rdata_r <= auto_out_prdata;
    end
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    initial begin
      automatic logic [31:0] _RANDOM[0:4];
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [2:0] i = 3'h0; i < 3'h5; i += 3'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        state = _RANDOM[3'h0][1:0];
        is_write_r = _RANDOM[3'h0][2];
        rid_reg = _RANDOM[3'h0][6:3];
        araddr_reg_r = {_RANDOM[3'h0][31:11], _RANDOM[3'h1][10:0]};
        awaddr_reg_r = {_RANDOM[3'h1][31:11], _RANDOM[3'h2][10:0]};
        wdata_reg_r = {_RANDOM[3'h2][31:11], _RANDOM[3'h3][10:0]};
        wstrb_reg_r = _RANDOM[3'h3][14:11];
        resp_hold_r = _RANDOM[3'h3][16:15];
        nodeIn_rdata_r = {_RANDOM[3'h3][31:17], _RANDOM[3'h4][16:0]};
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign auto_in_awready = accept_write;
  assign auto_in_wready = accept_write;
  assign auto_in_bvalid = nodeIn_bvalid;
  assign auto_in_arready = accept_read;
  assign auto_in_rvalid = nodeIn_rvalid;
  assign auto_in_rid = rid_reg;
  assign auto_in_rdata = nodeOut_penable ? auto_out_prdata : nodeIn_rdata_r;
  assign auto_in_rresp = nodeOut_penable ? resp : resp_hold_r;
  assign auto_out_psel = accept_read | accept_write | nodeOut_penable;
  assign auto_out_penable = nodeOut_penable;
  assign auto_out_pwrite = is_write;
  assign auto_out_paddr =
    is_write
      ? (accept_write ? auto_in_awaddr : awaddr_reg_r)
      : accept_read ? auto_in_araddr : araddr_reg_r;
  assign auto_out_pwdata = accept_write ? auto_in_wdata : wdata_reg_r;
  assign auto_out_pstrb =
    is_write ? (accept_write ? auto_in_wstrb : wstrb_reg_r) : 4'h0;
endmodule


// Include rmemory initializers in init blocks unless synthesis is set
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

// VCS coverage exclude_file
module ram_2x43(
  input         R0_addr,
                R0_en,
                R0_clk,
  output [42:0] R0_data,
  input         W0_addr,
                W0_en,
                W0_clk,
  input  [42:0] W0_data
);

  reg [42:0] Memory[0:1];
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_MEM_
    reg [63:0] _RANDOM_MEM;
    initial begin
      `INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_MEM_INIT
        for (logic [1:0] i = 2'h0; i < 2'h2; i += 2'h1) begin
          for (logic [6:0] j = 7'h0; j < 7'h40; j += 7'h20) begin
            _RANDOM_MEM[j +: 32] = `RANDOM;
          end
          Memory[i[0]] = _RANDOM_MEM[42:0];
        end
      `endif // RANDOMIZE_MEM_INIT
    end // initial
  `endif // ENABLE_INITIAL_MEM_
  assign R0_data = R0_en ? Memory[R0_addr] : 43'bx;
endmodule

module Queue2_AXI4BundleAW(
  input         clock,
                reset,
  output        io_enq_ready,
  input         io_enq_valid,
  input  [31:0] io_enq_bits_addr,
  input  [2:0]  io_enq_bits_size,
  input         io_deq_ready,
  output        io_deq_valid,
  output [31:0] io_deq_bits_addr,
  output [7:0]  io_deq_bits_len,
  output [2:0]  io_deq_bits_size
);

  wire [42:0] _ram_ext_R0_data;
  reg         wrap;
  reg         wrap_1;
  reg         maybe_full;
  wire        ptr_match = wrap == wrap_1;
  wire        empty = ptr_match & ~maybe_full;
  wire        full = ptr_match & maybe_full;
  wire        do_enq = ~full & io_enq_valid;
  always @(posedge clock) begin
    if (reset) begin
      wrap <= 1'h0;
      wrap_1 <= 1'h0;
      maybe_full <= 1'h0;
    end
    else begin
      automatic logic do_deq = io_deq_ready & ~empty;
      if (do_enq)
        wrap <= wrap - 1'h1;
      if (do_deq)
        wrap_1 <= wrap_1 - 1'h1;
      if (~(do_enq == do_deq))
        maybe_full <= do_enq;
    end
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    initial begin
      automatic logic [31:0] _RANDOM[0:0];
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        wrap = _RANDOM[/*Zero width*/ 1'b0][0];
        wrap_1 = _RANDOM[/*Zero width*/ 1'b0][1];
        maybe_full = _RANDOM[/*Zero width*/ 1'b0][2];
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  ram_2x43 ram_ext (
    .R0_addr (wrap_1),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_ram_ext_R0_data),
    .W0_addr (wrap),
    .W0_en   (do_enq),
    .W0_clk  (clock),
    .W0_data ({io_enq_bits_addr, 8'h0, io_enq_bits_size})
  );
  assign io_enq_ready = ~full;
  assign io_deq_valid = ~empty;
  assign io_deq_bits_addr = _ram_ext_R0_data[42:11];
  assign io_deq_bits_len = _ram_ext_R0_data[10:3];
  assign io_deq_bits_size = _ram_ext_R0_data[2:0];
endmodule

// VCS coverage exclude_file
module ram_2x36(
  input         R0_addr,
                R0_en,
                R0_clk,
  output [35:0] R0_data,
  input         W0_addr,
                W0_en,
                W0_clk,
  input  [35:0] W0_data
);

  reg [35:0] Memory[0:1];
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_MEM_
    reg [63:0] _RANDOM_MEM;
    initial begin
      `INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_MEM_INIT
        for (logic [1:0] i = 2'h0; i < 2'h2; i += 2'h1) begin
          for (logic [6:0] j = 7'h0; j < 7'h40; j += 7'h20) begin
            _RANDOM_MEM[j +: 32] = `RANDOM;
          end
          Memory[i[0]] = _RANDOM_MEM[35:0];
        end
      `endif // RANDOMIZE_MEM_INIT
    end // initial
  `endif // ENABLE_INITIAL_MEM_
  assign R0_data = R0_en ? Memory[R0_addr] : 36'bx;
endmodule

module Queue2_AXI4BundleW(
  input         clock,
                reset,
  output        io_enq_ready,
  input         io_enq_valid,
  input  [31:0] io_enq_bits_data,
  input  [3:0]  io_enq_bits_strb,
  input         io_deq_ready,
  output        io_deq_valid,
  output [31:0] io_deq_bits_data,
  output [3:0]  io_deq_bits_strb
);

  wire [35:0] _ram_ext_R0_data;
  reg         wrap;
  reg         wrap_1;
  reg         maybe_full;
  wire        ptr_match = wrap == wrap_1;
  wire        empty = ptr_match & ~maybe_full;
  wire        full = ptr_match & maybe_full;
  wire        do_enq = ~full & io_enq_valid;
  always @(posedge clock) begin
    if (reset) begin
      wrap <= 1'h0;
      wrap_1 <= 1'h0;
      maybe_full <= 1'h0;
    end
    else begin
      automatic logic do_deq = io_deq_ready & ~empty;
      if (do_enq)
        wrap <= wrap - 1'h1;
      if (do_deq)
        wrap_1 <= wrap_1 - 1'h1;
      if (~(do_enq == do_deq))
        maybe_full <= do_enq;
    end
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    initial begin
      automatic logic [31:0] _RANDOM[0:0];
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        wrap = _RANDOM[/*Zero width*/ 1'b0][0];
        wrap_1 = _RANDOM[/*Zero width*/ 1'b0][1];
        maybe_full = _RANDOM[/*Zero width*/ 1'b0][2];
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  ram_2x36 ram_ext (
    .R0_addr (wrap_1),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_ram_ext_R0_data),
    .W0_addr (wrap),
    .W0_en   (do_enq),
    .W0_clk  (clock),
    .W0_data ({io_enq_bits_data, io_enq_bits_strb})
  );
  assign io_enq_ready = ~full;
  assign io_deq_valid = ~empty;
  assign io_deq_bits_data = _ram_ext_R0_data[35:4];
  assign io_deq_bits_strb = _ram_ext_R0_data[3:0];
endmodule

module Queue2_AXI4BundleB(
  input  clock,
         reset,
  output io_enq_ready,
  input  io_enq_valid,
         io_deq_ready,
  output io_deq_valid
);

  reg  wrap;
  reg  wrap_1;
  reg  maybe_full;
  wire ptr_match = wrap == wrap_1;
  wire empty = ptr_match & ~maybe_full;
  wire full = ptr_match & maybe_full;
  always @(posedge clock) begin
    if (reset) begin
      wrap <= 1'h0;
      wrap_1 <= 1'h0;
      maybe_full <= 1'h0;
    end
    else begin
      automatic logic do_enq;
      automatic logic do_deq = io_deq_ready & ~empty;
      do_enq = ~full & io_enq_valid;
      if (do_enq)
        wrap <= wrap - 1'h1;
      if (do_deq)
        wrap_1 <= wrap_1 - 1'h1;
      if (~(do_enq == do_deq))
        maybe_full <= do_enq;
    end
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    initial begin
      automatic logic [31:0] _RANDOM[0:0];
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        wrap = _RANDOM[/*Zero width*/ 1'b0][0];
        wrap_1 = _RANDOM[/*Zero width*/ 1'b0][1];
        maybe_full = _RANDOM[/*Zero width*/ 1'b0][2];
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_enq_ready = ~full;
  assign io_deq_valid = ~empty;
endmodule

// VCS coverage exclude_file
module ram_2x47(
  input         R0_addr,
                R0_en,
                R0_clk,
  output [46:0] R0_data,
  input         W0_addr,
                W0_en,
                W0_clk,
  input  [46:0] W0_data
);

  reg [46:0] Memory[0:1];
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_MEM_
    reg [63:0] _RANDOM_MEM;
    initial begin
      `INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_MEM_INIT
        for (logic [1:0] i = 2'h0; i < 2'h2; i += 2'h1) begin
          for (logic [6:0] j = 7'h0; j < 7'h40; j += 7'h20) begin
            _RANDOM_MEM[j +: 32] = `RANDOM;
          end
          Memory[i[0]] = _RANDOM_MEM[46:0];
        end
      `endif // RANDOMIZE_MEM_INIT
    end // initial
  `endif // ENABLE_INITIAL_MEM_
  assign R0_data = R0_en ? Memory[R0_addr] : 47'bx;
endmodule

module Queue2_AXI4BundleAR(
  input         clock,
                reset,
  output        io_enq_ready,
  input         io_enq_valid,
  input  [31:0] io_enq_bits_addr,
  input  [2:0]  io_enq_bits_size,
  input         io_deq_ready,
  output        io_deq_valid,
  output [3:0]  io_deq_bits_id,
  output [31:0] io_deq_bits_addr,
  output [7:0]  io_deq_bits_len,
  output [2:0]  io_deq_bits_size
);

  wire [46:0] _ram_ext_R0_data;
  reg         wrap;
  reg         wrap_1;
  reg         maybe_full;
  wire        ptr_match = wrap == wrap_1;
  wire        empty = ptr_match & ~maybe_full;
  wire        full = ptr_match & maybe_full;
  wire        do_enq = ~full & io_enq_valid;
  always @(posedge clock) begin
    if (reset) begin
      wrap <= 1'h0;
      wrap_1 <= 1'h0;
      maybe_full <= 1'h0;
    end
    else begin
      automatic logic do_deq = io_deq_ready & ~empty;
      if (do_enq)
        wrap <= wrap - 1'h1;
      if (do_deq)
        wrap_1 <= wrap_1 - 1'h1;
      if (~(do_enq == do_deq))
        maybe_full <= do_enq;
    end
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    initial begin
      automatic logic [31:0] _RANDOM[0:0];
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        wrap = _RANDOM[/*Zero width*/ 1'b0][0];
        wrap_1 = _RANDOM[/*Zero width*/ 1'b0][1];
        maybe_full = _RANDOM[/*Zero width*/ 1'b0][2];
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  ram_2x47 ram_ext (
    .R0_addr (wrap_1),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_ram_ext_R0_data),
    .W0_addr (wrap),
    .W0_en   (do_enq),
    .W0_clk  (clock),
    .W0_data ({4'h0, io_enq_bits_addr, 8'h0, io_enq_bits_size})
  );
  assign io_enq_ready = ~full;
  assign io_deq_valid = ~empty;
  assign io_deq_bits_id = _ram_ext_R0_data[46:43];
  assign io_deq_bits_addr = _ram_ext_R0_data[42:11];
  assign io_deq_bits_len = _ram_ext_R0_data[10:3];
  assign io_deq_bits_size = _ram_ext_R0_data[2:0];
endmodule

// VCS coverage exclude_file
module ram_2x32(
  input         R0_addr,
                R0_en,
                R0_clk,
  output [31:0] R0_data,
  input         W0_addr,
                W0_en,
                W0_clk,
  input  [31:0] W0_data
);

  reg [31:0] Memory[0:1];
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_MEM_
    reg [31:0] _RANDOM_MEM;
    initial begin
      `INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_MEM_INIT
        for (logic [1:0] i = 2'h0; i < 2'h2; i += 2'h1) begin
          _RANDOM_MEM = `RANDOM;
          Memory[i[0]] = _RANDOM_MEM;
        end
      `endif // RANDOMIZE_MEM_INIT
    end // initial
  `endif // ENABLE_INITIAL_MEM_
  assign R0_data = R0_en ? Memory[R0_addr] : 32'bx;
endmodule

module Queue2_AXI4BundleR(
  input         clock,
                reset,
  output        io_enq_ready,
  input         io_enq_valid,
  input  [3:0]  io_enq_bits_id,
  input  [31:0] io_enq_bits_data,
  input  [1:0]  io_enq_bits_resp,
  input         io_deq_ready,
  output        io_deq_valid,
  output [31:0] io_deq_bits_data
);

  reg  wrap;
  reg  wrap_1;
  reg  maybe_full;
  wire ptr_match = wrap == wrap_1;
  wire empty = ptr_match & ~maybe_full;
  wire full = ptr_match & maybe_full;
  wire do_enq = ~full & io_enq_valid;
  always @(posedge clock) begin
    if (reset) begin
      wrap <= 1'h0;
      wrap_1 <= 1'h0;
      maybe_full <= 1'h0;
    end
    else begin
      automatic logic do_deq = io_deq_ready & ~empty;
      if (do_enq)
        wrap <= wrap - 1'h1;
      if (do_deq)
        wrap_1 <= wrap_1 - 1'h1;
      if (~(do_enq == do_deq))
        maybe_full <= do_enq;
    end
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    initial begin
      automatic logic [31:0] _RANDOM[0:0];
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        wrap = _RANDOM[/*Zero width*/ 1'b0][0];
        wrap_1 = _RANDOM[/*Zero width*/ 1'b0][1];
        maybe_full = _RANDOM[/*Zero width*/ 1'b0][2];
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  ram_2x32 ram_ext (
    .R0_addr (wrap_1),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (io_deq_bits_data),
    .W0_addr (wrap),
    .W0_en   (do_enq),
    .W0_clk  (clock),
    .W0_data (io_enq_bits_data)
  );
  assign io_enq_ready = ~full;
  assign io_deq_valid = ~empty;
endmodule

module AXI4Buffer(
  input         clock,
                reset,
  output        auto_in_awready,
  input         auto_in_awvalid,
  input  [31:0] auto_in_awaddr,
  input  [2:0]  auto_in_awsize,
  output        auto_in_wready,
  input         auto_in_wvalid,
  input  [31:0] auto_in_wdata,
  input  [3:0]  auto_in_wstrb,
  input         auto_in_bready,
  output        auto_in_bvalid,
                auto_in_arready,
  input         auto_in_arvalid,
  input  [31:0] auto_in_araddr,
  input  [2:0]  auto_in_arsize,
  input         auto_in_rready,
  output        auto_in_rvalid,
  output [31:0] auto_in_rdata,
  input         auto_out_awready,
  output        auto_out_awvalid,
  output [31:0] auto_out_awaddr,
  output [7:0]  auto_out_awlen,
  output [2:0]  auto_out_awsize,
  input         auto_out_wready,
  output        auto_out_wvalid,
  output [31:0] auto_out_wdata,
  output [3:0]  auto_out_wstrb,
  output        auto_out_bready,
  input         auto_out_bvalid,
                auto_out_arready,
  output        auto_out_arvalid,
  output [3:0]  auto_out_arid,
  output [31:0] auto_out_araddr,
  output [7:0]  auto_out_arlen,
  output [2:0]  auto_out_arsize,
  output        auto_out_rready,
  input         auto_out_rvalid,
  input  [3:0]  auto_out_rid,
  input  [31:0] auto_out_rdata,
  input  [1:0]  auto_out_rresp
);

  Queue2_AXI4BundleAW nodeOut_awdeq_q (
    .clock            (clock),
    .reset            (reset),
    .io_enq_ready     (auto_in_awready),
    .io_enq_valid     (auto_in_awvalid),
    .io_enq_bits_addr (auto_in_awaddr),
    .io_enq_bits_size (auto_in_awsize),
    .io_deq_ready     (auto_out_awready),
    .io_deq_valid     (auto_out_awvalid),
    .io_deq_bits_addr (auto_out_awaddr),
    .io_deq_bits_len  (auto_out_awlen),
    .io_deq_bits_size (auto_out_awsize)
  );
  Queue2_AXI4BundleW nodeOut_wdeq_q (
    .clock            (clock),
    .reset            (reset),
    .io_enq_ready     (auto_in_wready),
    .io_enq_valid     (auto_in_wvalid),
    .io_enq_bits_data (auto_in_wdata),
    .io_enq_bits_strb (auto_in_wstrb),
    .io_deq_ready     (auto_out_wready),
    .io_deq_valid     (auto_out_wvalid),
    .io_deq_bits_data (auto_out_wdata),
    .io_deq_bits_strb (auto_out_wstrb)
  );
  Queue2_AXI4BundleB nodeIn_bdeq_q (
    .clock        (clock),
    .reset        (reset),
    .io_enq_ready (auto_out_bready),
    .io_enq_valid (auto_out_bvalid),
    .io_deq_ready (auto_in_bready),
    .io_deq_valid (auto_in_bvalid)
  );
  Queue2_AXI4BundleAR nodeOut_ardeq_q (
    .clock            (clock),
    .reset            (reset),
    .io_enq_ready     (auto_in_arready),
    .io_enq_valid     (auto_in_arvalid),
    .io_enq_bits_addr (auto_in_araddr),
    .io_enq_bits_size (auto_in_arsize),
    .io_deq_ready     (auto_out_arready),
    .io_deq_valid     (auto_out_arvalid),
    .io_deq_bits_id   (auto_out_arid),
    .io_deq_bits_addr (auto_out_araddr),
    .io_deq_bits_len  (auto_out_arlen),
    .io_deq_bits_size (auto_out_arsize)
  );
  Queue2_AXI4BundleR nodeIn_rdeq_q (
    .clock            (clock),
    .reset            (reset),
    .io_enq_ready     (auto_out_rready),
    .io_enq_valid     (auto_out_rvalid),
    .io_enq_bits_id   (auto_out_rid),
    .io_enq_bits_data (auto_out_rdata),
    .io_enq_bits_resp (auto_out_rresp),
    .io_deq_ready     (auto_in_rready),
    .io_deq_valid     (auto_in_rvalid),
    .io_deq_bits_data (auto_in_rdata)
  );
endmodule

module NonSyncResetSynchronizerPrimitiveShiftReg_d10(
  input  clock,
         io_d,
  output io_q
);

  reg sync_0;
  reg sync_1;
  reg sync_2;
  reg sync_3;
  reg sync_4;
  reg sync_5;
  reg sync_6;
  reg sync_7;
  reg sync_8;
  reg sync_9;
  always @(posedge clock) begin
    sync_0 <= sync_1;
    sync_1 <= sync_2;
    sync_2 <= sync_3;
    sync_3 <= sync_4;
    sync_4 <= sync_5;
    sync_5 <= sync_6;
    sync_6 <= sync_7;
    sync_7 <= sync_8;
    sync_8 <= sync_9;
    sync_9 <= io_d;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    initial begin
      automatic logic [31:0] _RANDOM[0:0];
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        sync_0 = _RANDOM[/*Zero width*/ 1'b0][0];
        sync_1 = _RANDOM[/*Zero width*/ 1'b0][1];
        sync_2 = _RANDOM[/*Zero width*/ 1'b0][2];
        sync_3 = _RANDOM[/*Zero width*/ 1'b0][3];
        sync_4 = _RANDOM[/*Zero width*/ 1'b0][4];
        sync_5 = _RANDOM[/*Zero width*/ 1'b0][5];
        sync_6 = _RANDOM[/*Zero width*/ 1'b0][6];
        sync_7 = _RANDOM[/*Zero width*/ 1'b0][7];
        sync_8 = _RANDOM[/*Zero width*/ 1'b0][8];
        sync_9 = _RANDOM[/*Zero width*/ 1'b0][9];
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_q = sync_0;
endmodule

module SynchronizerShiftReg_w1_d10(
  input  clock,
         io_d,
  output io_q
);

  NonSyncResetSynchronizerPrimitiveShiftReg_d10 output_chain (
    .clock (clock),
    .io_d  (io_d),
    .io_q  (io_q)
  );
endmodule

module ysyxSoCASIC(
  input         clock,
                reset,
  output        spi_sck,
  output [7:0]  spi_ss,
  output        spi_mosi,
  input         spi_miso,
                uart_rx,
  output        uart_tx,
                sdram_clk,
                sdram_cke,
                sdram_cs,
                sdram_ras,
                sdram_cas,
                sdram_we,
  output [12:0] sdram_a,
  output [1:0]  sdram_ba,
                sdram_dqm,
  inout  [15:0] sdram_dq
);

  wire        _cpu_reset_chain_io_q;
  wire        _axi4buf_auto_in_awready;
  wire        _axi4buf_auto_in_wready;
  wire        _axi4buf_auto_in_bvalid;
  wire        _axi4buf_auto_in_arready;
  wire        _axi4buf_auto_in_rvalid;
  wire [31:0] _axi4buf_auto_in_rdata;
  wire        _axi4buf_auto_out_awvalid;
  wire [31:0] _axi4buf_auto_out_awaddr;
  wire [7:0]  _axi4buf_auto_out_awlen;
  wire [2:0]  _axi4buf_auto_out_awsize;
  wire        _axi4buf_auto_out_wvalid;
  wire [31:0] _axi4buf_auto_out_wdata;
  wire [3:0]  _axi4buf_auto_out_wstrb;
  wire        _axi4buf_auto_out_bready;
  wire        _axi4buf_auto_out_arvalid;
  wire [3:0]  _axi4buf_auto_out_arid;
  wire [31:0] _axi4buf_auto_out_araddr;
  wire [7:0]  _axi4buf_auto_out_arlen;
  wire [2:0]  _axi4buf_auto_out_arsize;
  wire        _axi4buf_auto_out_rready;
  wire        _axi42apb_auto_in_awready;
  wire        _axi42apb_auto_in_wready;
  wire        _axi42apb_auto_in_bvalid;
  wire        _axi42apb_auto_in_arready;
  wire        _axi42apb_auto_in_rvalid;
  wire [3:0]  _axi42apb_auto_in_rid;
  wire [31:0] _axi42apb_auto_in_rdata;
  wire [1:0]  _axi42apb_auto_in_rresp;
  wire        _axi42apb_auto_out_psel;
  wire        _axi42apb_auto_out_penable;
  wire        _axi42apb_auto_out_pwrite;
  wire [31:0] _axi42apb_auto_out_paddr;
  wire [31:0] _axi42apb_auto_out_pwdata;
  wire [3:0]  _axi42apb_auto_out_pstrb;
  wire        _apbdelay_delayer_in_pready;
  wire        _apbdelay_delayer_in_pslverr;
  wire [31:0] _apbdelay_delayer_in_prdata;
  wire        _apbdelay_delayer_out_psel;
  wire        _apbdelay_delayer_out_penable;
  wire        _apbdelay_delayer_out_pwrite;
  wire [31:0] _apbdelay_delayer_out_paddr;
  wire [2:0]  _apbdelay_delayer_out_pprot;
  wire [31:0] _apbdelay_delayer_out_pwdata;
  wire [3:0]  _apbdelay_delayer_out_pstrb;
  wire        _lsdram_apb_auto_in_pready;
  wire        _lsdram_apb_auto_in_pslverr;
  wire [31:0] _lsdram_apb_auto_in_prdata;
  wire        _lspi_auto_in_pready;
  wire [31:0] _lspi_auto_in_prdata;
  wire        _luart_auto_in_pready;
  wire        _luart_auto_in_pslverr;
  wire [31:0] _luart_auto_in_prdata;
  wire        _cpu_auto_master_out_awvalid;
  wire [31:0] _cpu_auto_master_out_awaddr;
  wire [2:0]  _cpu_auto_master_out_awsize;
  wire        _cpu_auto_master_out_wvalid;
  wire [31:0] _cpu_auto_master_out_wdata;
  wire [3:0]  _cpu_auto_master_out_wstrb;
  wire        _cpu_auto_master_out_bready;
  wire        _cpu_auto_master_out_arvalid;
  wire [31:0] _cpu_auto_master_out_araddr;
  wire [2:0]  _cpu_auto_master_out_arsize;
  wire        _cpu_auto_master_out_rready;
  wire        _apbxbar_auto_anon_in_pready;
  wire        _apbxbar_auto_anon_in_pslverr;
  wire [31:0] _apbxbar_auto_anon_in_prdata;
  wire        _apbxbar_auto_anon_out_2_psel;
  wire        _apbxbar_auto_anon_out_2_penable;
  wire        _apbxbar_auto_anon_out_2_pwrite;
  wire [31:0] _apbxbar_auto_anon_out_2_paddr;
  wire [2:0]  _apbxbar_auto_anon_out_2_pprot;
  wire [31:0] _apbxbar_auto_anon_out_2_pwdata;
  wire [3:0]  _apbxbar_auto_anon_out_2_pstrb;
  wire        _apbxbar_auto_anon_out_1_psel;
  wire        _apbxbar_auto_anon_out_1_penable;
  wire        _apbxbar_auto_anon_out_1_pwrite;
  wire [28:0] _apbxbar_auto_anon_out_1_paddr;
  wire [2:0]  _apbxbar_auto_anon_out_1_pprot;
  wire [31:0] _apbxbar_auto_anon_out_1_pwdata;
  wire [3:0]  _apbxbar_auto_anon_out_1_pstrb;
  wire        _apbxbar_auto_anon_out_0_psel;
  wire        _apbxbar_auto_anon_out_0_penable;
  wire        _apbxbar_auto_anon_out_0_pwrite;
  wire [29:0] _apbxbar_auto_anon_out_0_paddr;
  wire [2:0]  _apbxbar_auto_anon_out_0_pprot;
  wire [31:0] _apbxbar_auto_anon_out_0_pwdata;
  wire [3:0]  _apbxbar_auto_anon_out_0_pstrb;
  wire        _axi4xbar_auto_anon_in_awready;
  wire        _axi4xbar_auto_anon_in_wready;
  wire        _axi4xbar_auto_anon_in_bvalid;
  wire        _axi4xbar_auto_anon_in_arready;
  wire        _axi4xbar_auto_anon_in_rvalid;
  wire [31:0] _axi4xbar_auto_anon_in_rdata;
  wire        _axi4xbar_auto_anon_out_awvalid;
  wire [31:0] _axi4xbar_auto_anon_out_awaddr;
  wire [2:0]  _axi4xbar_auto_anon_out_awsize;
  wire        _axi4xbar_auto_anon_out_wvalid;
  wire [31:0] _axi4xbar_auto_anon_out_wdata;
  wire [3:0]  _axi4xbar_auto_anon_out_wstrb;
  wire        _axi4xbar_auto_anon_out_bready;
  wire        _axi4xbar_auto_anon_out_arvalid;
  wire [31:0] _axi4xbar_auto_anon_out_araddr;
  wire [2:0]  _axi4xbar_auto_anon_out_arsize;
  wire        _axi4xbar_auto_anon_out_rready;
  AXI4Xbar axi4xbar (
    .clock                      (clock),
    .reset                      (reset),
    .auto_anon_in_awready      (_axi4xbar_auto_anon_in_awready),
    .auto_anon_in_awvalid      (_cpu_auto_master_out_awvalid),
    .auto_anon_in_awaddr  (_cpu_auto_master_out_awaddr),
    .auto_anon_in_awsize  (_cpu_auto_master_out_awsize),
    .auto_anon_in_wready       (_axi4xbar_auto_anon_in_wready),
    .auto_anon_in_wvalid       (_cpu_auto_master_out_wvalid),
    .auto_anon_in_wdata   (_cpu_auto_master_out_wdata),
    .auto_anon_in_wstrb   (_cpu_auto_master_out_wstrb),
    .auto_anon_in_bready       (_cpu_auto_master_out_bready),
    .auto_anon_in_bvalid       (_axi4xbar_auto_anon_in_bvalid),
    .auto_anon_in_arready      (_axi4xbar_auto_anon_in_arready),
    .auto_anon_in_arvalid      (_cpu_auto_master_out_arvalid),
    .auto_anon_in_araddr  (_cpu_auto_master_out_araddr),
    .auto_anon_in_arsize  (_cpu_auto_master_out_arsize),
    .auto_anon_in_rready       (_cpu_auto_master_out_rready),
    .auto_anon_in_rvalid       (_axi4xbar_auto_anon_in_rvalid),
    .auto_anon_in_rdata   (_axi4xbar_auto_anon_in_rdata),
    .auto_anon_out_awready     (_axi4buf_auto_in_awready),
    .auto_anon_out_awvalid     (_axi4xbar_auto_anon_out_awvalid),
    .auto_anon_out_awaddr (_axi4xbar_auto_anon_out_awaddr),
    .auto_anon_out_awsize (_axi4xbar_auto_anon_out_awsize),
    .auto_anon_out_wready      (_axi4buf_auto_in_wready),
    .auto_anon_out_wvalid      (_axi4xbar_auto_anon_out_wvalid),
    .auto_anon_out_wdata  (_axi4xbar_auto_anon_out_wdata),
    .auto_anon_out_wstrb  (_axi4xbar_auto_anon_out_wstrb),
    .auto_anon_out_bready      (_axi4xbar_auto_anon_out_bready),
    .auto_anon_out_bvalid      (_axi4buf_auto_in_bvalid),
    .auto_anon_out_arready     (_axi4buf_auto_in_arready),
    .auto_anon_out_arvalid     (_axi4xbar_auto_anon_out_arvalid),
    .auto_anon_out_araddr (_axi4xbar_auto_anon_out_araddr),
    .auto_anon_out_arsize (_axi4xbar_auto_anon_out_arsize),
    .auto_anon_out_rready      (_axi4xbar_auto_anon_out_rready),
    .auto_anon_out_rvalid      (_axi4buf_auto_in_rvalid),
    .auto_anon_out_rdata  (_axi4buf_auto_in_rdata)
  );
  APBFanout apbxbar (
    .auto_anon_in_psel       (_apbdelay_delayer_out_psel),
    .auto_anon_in_penable    (_apbdelay_delayer_out_penable),
    .auto_anon_in_pwrite     (_apbdelay_delayer_out_pwrite),
    .auto_anon_in_paddr      (_apbdelay_delayer_out_paddr),
    .auto_anon_in_pprot      (_apbdelay_delayer_out_pprot),
    .auto_anon_in_pwdata     (_apbdelay_delayer_out_pwdata),
    .auto_anon_in_pstrb      (_apbdelay_delayer_out_pstrb),
    .auto_anon_in_pready     (_apbxbar_auto_anon_in_pready),
    .auto_anon_in_pslverr    (_apbxbar_auto_anon_in_pslverr),
    .auto_anon_in_prdata     (_apbxbar_auto_anon_in_prdata),
    .auto_anon_out_2_psel    (_apbxbar_auto_anon_out_2_psel),
    .auto_anon_out_2_penable (_apbxbar_auto_anon_out_2_penable),
    .auto_anon_out_2_pwrite  (_apbxbar_auto_anon_out_2_pwrite),
    .auto_anon_out_2_paddr   (_apbxbar_auto_anon_out_2_paddr),
    .auto_anon_out_2_pprot   (_apbxbar_auto_anon_out_2_pprot),
    .auto_anon_out_2_pwdata  (_apbxbar_auto_anon_out_2_pwdata),
    .auto_anon_out_2_pstrb   (_apbxbar_auto_anon_out_2_pstrb),
    .auto_anon_out_2_pready  (_lsdram_apb_auto_in_pready),
    .auto_anon_out_2_pslverr (_lsdram_apb_auto_in_pslverr),
    .auto_anon_out_2_prdata  (_lsdram_apb_auto_in_prdata),
    .auto_anon_out_1_psel    (_apbxbar_auto_anon_out_1_psel),
    .auto_anon_out_1_penable (_apbxbar_auto_anon_out_1_penable),
    .auto_anon_out_1_pwrite  (_apbxbar_auto_anon_out_1_pwrite),
    .auto_anon_out_1_paddr   (_apbxbar_auto_anon_out_1_paddr),
    .auto_anon_out_1_pprot   (_apbxbar_auto_anon_out_1_pprot),
    .auto_anon_out_1_pwdata  (_apbxbar_auto_anon_out_1_pwdata),
    .auto_anon_out_1_pstrb   (_apbxbar_auto_anon_out_1_pstrb),
    .auto_anon_out_1_pready  (_luart_auto_in_pready),
    .auto_anon_out_1_pslverr (_luart_auto_in_pslverr),
    .auto_anon_out_1_prdata  (_luart_auto_in_prdata),
    .auto_anon_out_0_psel    (_apbxbar_auto_anon_out_0_psel),
    .auto_anon_out_0_penable (_apbxbar_auto_anon_out_0_penable),
    .auto_anon_out_0_pwrite  (_apbxbar_auto_anon_out_0_pwrite),
    .auto_anon_out_0_paddr   (_apbxbar_auto_anon_out_0_paddr),
    .auto_anon_out_0_pprot   (_apbxbar_auto_anon_out_0_pprot),
    .auto_anon_out_0_pwdata  (_apbxbar_auto_anon_out_0_pwdata),
    .auto_anon_out_0_pstrb   (_apbxbar_auto_anon_out_0_pstrb),
    .auto_anon_out_0_pready  (_lspi_auto_in_pready),
    .auto_anon_out_0_prdata  (_lspi_auto_in_prdata)
  );
  CPU cpu (
    .clock                        (clock),
    .reset                        (_cpu_reset_chain_io_q | reset),
    .auto_master_out_awready     (_axi4xbar_auto_anon_in_awready),
    .auto_master_out_awvalid     (_cpu_auto_master_out_awvalid),
    .auto_master_out_awaddr (_cpu_auto_master_out_awaddr),
    .auto_master_out_awsize (_cpu_auto_master_out_awsize),
    .auto_master_out_wready      (_axi4xbar_auto_anon_in_wready),
    .auto_master_out_wvalid      (_cpu_auto_master_out_wvalid),
    .auto_master_out_wdata  (_cpu_auto_master_out_wdata),
    .auto_master_out_wstrb  (_cpu_auto_master_out_wstrb),
    .auto_master_out_bready      (_cpu_auto_master_out_bready),
    .auto_master_out_bvalid      (_axi4xbar_auto_anon_in_bvalid),
    .auto_master_out_arready     (_axi4xbar_auto_anon_in_arready),
    .auto_master_out_arvalid     (_cpu_auto_master_out_arvalid),
    .auto_master_out_araddr (_cpu_auto_master_out_araddr),
    .auto_master_out_arsize (_cpu_auto_master_out_arsize),
    .auto_master_out_rready      (_cpu_auto_master_out_rready),
    .auto_master_out_rvalid      (_axi4xbar_auto_anon_in_rvalid),
    .auto_master_out_rdata  (_axi4xbar_auto_anon_in_rdata)
  );
  APBUart16550 luart (
    .clock           (clock),
    .reset           (reset),
    .auto_in_psel    (_apbxbar_auto_anon_out_1_psel),
    .auto_in_penable (_apbxbar_auto_anon_out_1_penable),
    .auto_in_pwrite  (_apbxbar_auto_anon_out_1_pwrite),
    .auto_in_paddr   (_apbxbar_auto_anon_out_1_paddr),
    .auto_in_pprot   (_apbxbar_auto_anon_out_1_pprot),
    .auto_in_pwdata  (_apbxbar_auto_anon_out_1_pwdata),
    .auto_in_pstrb   (_apbxbar_auto_anon_out_1_pstrb),
    .auto_in_pready  (_luart_auto_in_pready),
    .auto_in_pslverr (_luart_auto_in_pslverr),
    .auto_in_prdata  (_luart_auto_in_prdata),
    .uart_rx         (uart_rx),
    .uart_tx         (uart_tx)
  );
  APBSPI lspi (
    .clock           (clock),
    .reset           (reset),
    .auto_in_psel    (_apbxbar_auto_anon_out_0_psel),
    .auto_in_penable (_apbxbar_auto_anon_out_0_penable),
    .auto_in_pwrite  (_apbxbar_auto_anon_out_0_pwrite),
    .auto_in_paddr   (_apbxbar_auto_anon_out_0_paddr),
    .auto_in_pprot   (_apbxbar_auto_anon_out_0_pprot),
    .auto_in_pwdata  (_apbxbar_auto_anon_out_0_pwdata),
    .auto_in_pstrb   (_apbxbar_auto_anon_out_0_pstrb),
    .auto_in_pready  (_lspi_auto_in_pready),
    .auto_in_prdata  (_lspi_auto_in_prdata),
    .spi_bundle_sck  (spi_sck),
    .spi_bundle_ss   (spi_ss),
    .spi_bundle_mosi (spi_mosi),
    .spi_bundle_miso (spi_miso)
  );
  APBSDRAM lsdram_apb (
    .clock            (clock),
    .reset            (reset),
    .auto_in_psel     (_apbxbar_auto_anon_out_2_psel),
    .auto_in_penable  (_apbxbar_auto_anon_out_2_penable),
    .auto_in_pwrite   (_apbxbar_auto_anon_out_2_pwrite),
    .auto_in_paddr    (_apbxbar_auto_anon_out_2_paddr),
    .auto_in_pprot    (_apbxbar_auto_anon_out_2_pprot),
    .auto_in_pwdata   (_apbxbar_auto_anon_out_2_pwdata),
    .auto_in_pstrb    (_apbxbar_auto_anon_out_2_pstrb),
    .auto_in_pready   (_lsdram_apb_auto_in_pready),
    .auto_in_pslverr  (_lsdram_apb_auto_in_pslverr),
    .auto_in_prdata   (_lsdram_apb_auto_in_prdata),
    .sdram_bundle_clk (sdram_clk),
    .sdram_bundle_cke (sdram_cke),
    .sdram_bundle_cs  (sdram_cs),
    .sdram_bundle_ras (sdram_ras),
    .sdram_bundle_cas (sdram_cas),
    .sdram_bundle_we  (sdram_we),
    .sdram_bundle_a   (sdram_a),
    .sdram_bundle_ba  (sdram_ba),
    .sdram_bundle_dqm (sdram_dqm),
    .sdram_bundle_dq  (sdram_dq)
  );
  apb_delayer apbdelay_delayer (
    .clock       (clock),
    .reset       (reset),
    .in_psel     (_axi42apb_auto_out_psel),
    .in_penable  (_axi42apb_auto_out_penable),
    .in_pwrite   (_axi42apb_auto_out_pwrite),
    .in_paddr    (_axi42apb_auto_out_paddr),
    .in_pprot    (3'h1),
    .in_pwdata   (_axi42apb_auto_out_pwdata),
    .in_pstrb    (_axi42apb_auto_out_pstrb),
    .in_pready   (_apbdelay_delayer_in_pready),
    .in_pslverr  (_apbdelay_delayer_in_pslverr),
    .in_prdata   (_apbdelay_delayer_in_prdata),
    .out_psel    (_apbdelay_delayer_out_psel),
    .out_penable (_apbdelay_delayer_out_penable),
    .out_pwrite  (_apbdelay_delayer_out_pwrite),
    .out_paddr   (_apbdelay_delayer_out_paddr),
    .out_pprot   (_apbdelay_delayer_out_pprot),
    .out_pwdata  (_apbdelay_delayer_out_pwdata),
    .out_pstrb   (_apbdelay_delayer_out_pstrb),
    .out_pready  (_apbxbar_auto_anon_in_pready),
    .out_pslverr (_apbxbar_auto_anon_in_pslverr),
    .out_prdata  (_apbxbar_auto_anon_in_prdata)
  );
  AXI4ToAPB axi42apb (
    .clock                (clock),
    .reset                (reset),
    .auto_in_awready     (_axi42apb_auto_in_awready),
    .auto_in_awvalid     (_axi4buf_auto_out_awvalid),
    .auto_in_awaddr (_axi4buf_auto_out_awaddr),
    .auto_in_awlen  (_axi4buf_auto_out_awlen),
    .auto_in_awsize (_axi4buf_auto_out_awsize),
    .auto_in_wready      (_axi42apb_auto_in_wready),
    .auto_in_wvalid      (_axi4buf_auto_out_wvalid),
    .auto_in_wdata  (_axi4buf_auto_out_wdata),
    .auto_in_wstrb  (_axi4buf_auto_out_wstrb),
    .auto_in_bready      (_axi4buf_auto_out_bready),
    .auto_in_bvalid      (_axi42apb_auto_in_bvalid),
    .auto_in_arready     (_axi42apb_auto_in_arready),
    .auto_in_arvalid     (_axi4buf_auto_out_arvalid),
    .auto_in_arid   (_axi4buf_auto_out_arid),
    .auto_in_araddr (_axi4buf_auto_out_araddr),
    .auto_in_arlen  (_axi4buf_auto_out_arlen),
    .auto_in_arsize (_axi4buf_auto_out_arsize),
    .auto_in_rready      (_axi4buf_auto_out_rready),
    .auto_in_rvalid      (_axi42apb_auto_in_rvalid),
    .auto_in_rid    (_axi42apb_auto_in_rid),
    .auto_in_rdata  (_axi42apb_auto_in_rdata),
    .auto_in_rresp  (_axi42apb_auto_in_rresp),
    .auto_out_psel        (_axi42apb_auto_out_psel),
    .auto_out_penable     (_axi42apb_auto_out_penable),
    .auto_out_pwrite      (_axi42apb_auto_out_pwrite),
    .auto_out_paddr       (_axi42apb_auto_out_paddr),
    .auto_out_pwdata      (_axi42apb_auto_out_pwdata),
    .auto_out_pstrb       (_axi42apb_auto_out_pstrb),
    .auto_out_pready      (_apbdelay_delayer_in_pready),
    .auto_out_pslverr     (_apbdelay_delayer_in_pslverr),
    .auto_out_prdata      (_apbdelay_delayer_in_prdata)
  );
  AXI4Buffer axi4buf (
    .clock                 (clock),
    .reset                 (reset),
    .auto_in_awready      (_axi4buf_auto_in_awready),
    .auto_in_awvalid      (_axi4xbar_auto_anon_out_awvalid),
    .auto_in_awaddr  (_axi4xbar_auto_anon_out_awaddr),
    .auto_in_awsize  (_axi4xbar_auto_anon_out_awsize),
    .auto_in_wready       (_axi4buf_auto_in_wready),
    .auto_in_wvalid       (_axi4xbar_auto_anon_out_wvalid),
    .auto_in_wdata   (_axi4xbar_auto_anon_out_wdata),
    .auto_in_wstrb   (_axi4xbar_auto_anon_out_wstrb),
    .auto_in_bready       (_axi4xbar_auto_anon_out_bready),
    .auto_in_bvalid       (_axi4buf_auto_in_bvalid),
    .auto_in_arready      (_axi4buf_auto_in_arready),
    .auto_in_arvalid      (_axi4xbar_auto_anon_out_arvalid),
    .auto_in_araddr  (_axi4xbar_auto_anon_out_araddr),
    .auto_in_arsize  (_axi4xbar_auto_anon_out_arsize),
    .auto_in_rready       (_axi4xbar_auto_anon_out_rready),
    .auto_in_rvalid       (_axi4buf_auto_in_rvalid),
    .auto_in_rdata   (_axi4buf_auto_in_rdata),
    .auto_out_awready     (_axi42apb_auto_in_awready),
    .auto_out_awvalid     (_axi4buf_auto_out_awvalid),
    .auto_out_awaddr (_axi4buf_auto_out_awaddr),
    .auto_out_awlen  (_axi4buf_auto_out_awlen),
    .auto_out_awsize (_axi4buf_auto_out_awsize),
    .auto_out_wready      (_axi42apb_auto_in_wready),
    .auto_out_wvalid      (_axi4buf_auto_out_wvalid),
    .auto_out_wdata  (_axi4buf_auto_out_wdata),
    .auto_out_wstrb  (_axi4buf_auto_out_wstrb),
    .auto_out_bready      (_axi4buf_auto_out_bready),
    .auto_out_bvalid      (_axi42apb_auto_in_bvalid),
    .auto_out_arready     (_axi42apb_auto_in_arready),
    .auto_out_arvalid     (_axi4buf_auto_out_arvalid),
    .auto_out_arid   (_axi4buf_auto_out_arid),
    .auto_out_araddr (_axi4buf_auto_out_araddr),
    .auto_out_arlen  (_axi4buf_auto_out_arlen),
    .auto_out_arsize (_axi4buf_auto_out_arsize),
    .auto_out_rready      (_axi4buf_auto_out_rready),
    .auto_out_rvalid      (_axi42apb_auto_in_rvalid),
    .auto_out_rid    (_axi42apb_auto_in_rid),
    .auto_out_rdata  (_axi42apb_auto_in_rdata),
    .auto_out_rresp  (_axi42apb_auto_in_rresp)
  );
  SynchronizerShiftReg_w1_d10 cpu_reset_chain (
    .clock (clock),
    .io_d  (reset),
    .io_q  (_cpu_reset_chain_io_q)
  );
endmodule

// VCS coverage exclude_file
module mem_16777216x16(
  input  [23:0] R0_addr,
  input         R0_en,
                R0_clk,
  output [15:0] R0_data,
  input  [23:0] W0_addr,
  input         W0_en,
                W0_clk,
  input  [15:0] W0_data,
  input  [1:0]  W0_mask
);

  reg [15:0] Memory[0:16777215];
  reg        _R0_en_d0;
  reg [23:0] _R0_addr_d0;
  always @(posedge R0_clk) begin
    _R0_en_d0 <= R0_en;
    _R0_addr_d0 <= R0_addr;
  end // always @(posedge)
  always @(posedge W0_clk) begin
    if (W0_en & W0_mask[0])
      Memory[W0_addr][32'h0 +: 8] <= W0_data[7:0];
    if (W0_en & W0_mask[1])
      Memory[W0_addr][32'h8 +: 8] <= W0_data[15:8];
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_MEM_
    `ifdef RANDOMIZE_REG_INIT
      reg [31:0] _RANDOM;
    `endif // RANDOMIZE_REG_INIT
    reg [31:0] _RANDOM_MEM;
    initial begin
      `INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_MEM_INIT
        for (logic [24:0] i = 25'h0; i < 25'h1000000; i += 25'h1) begin
          _RANDOM_MEM = `RANDOM;
          Memory[i[23:0]] = _RANDOM_MEM[15:0];
        end
      `endif // RANDOMIZE_MEM_INIT
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM = {`RANDOM};
        _R0_en_d0 = _RANDOM[0];
        _R0_addr_d0 = _RANDOM[24:1];
      `endif // RANDOMIZE_REG_INIT
    end // initial
  `endif // ENABLE_INITIAL_MEM_
  assign R0_data = _R0_en_d0 ? Memory[_R0_addr_d0] : 16'bx;
endmodule

// VCS coverage exclude_file
module rowReg_4x13(
  input  [1:0]  R0_addr,
  input         R0_en,
                R0_clk,
  output [12:0] R0_data,
  input  [1:0]  W0_addr,
  input         W0_en,
                W0_clk,
  input  [12:0] W0_data
);

  reg [12:0] Memory[0:3];
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_MEM_
    reg [31:0] _RANDOM_MEM;
    initial begin
      `INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_MEM_INIT
        for (logic [2:0] i = 3'h0; i < 3'h4; i += 3'h1) begin
          _RANDOM_MEM = `RANDOM;
          Memory[i[1:0]] = _RANDOM_MEM[12:0];
        end
      `endif // RANDOMIZE_MEM_INIT
    end // initial
  `endif // ENABLE_INITIAL_MEM_
  assign R0_data = R0_en ? Memory[R0_addr] : 13'bx;
endmodule

module sdramChisel(
  input        io_clk,
               io_cke,
               io_cs,
               io_ras,
               io_cas,
               io_we,
  input [12:0] io_a,
  input [1:0]  io_ba,
               io_dqm,
  inout [15:0] io_dq
);

  reg  [3:0]  word_remain_1;
  wire [15:0] _di_buf_din;
  wire [12:0] _rowReg_ext_R0_data;
  wire [15:0] _mem_ext_R0_data;
  wire [3:0]  cmd = {io_cs, io_ras, io_cas, io_we};
  reg  [12:0] mode;
  reg  [3:0]  word_remain;
  reg  [23:0] raddr_s1;
  reg  [23:0] waddr_s1;
  reg         di_REG;
  reg  [15:0] REG;
  reg  [1:0]  r;
  always @(posedge io_clk) begin
    automatic logic       _GEN = io_cke & cmd == 4'h5;
    automatic logic [3:0] _GEN_0;
    automatic logic       _GEN_1 = io_cke & cmd == 4'h4;
    _GEN_0 = {2'h0, mode[1:0]};
    if (io_cke & cmd == 4'h0)
      mode <= io_a;
    word_remain <= _GEN ? 4'h1 << _GEN_0 : (|word_remain) ? word_remain - 4'h1 : 4'h0;
    raddr_s1 <=
      _GEN ? {_rowReg_ext_R0_data, io_ba, io_a[8:0]} : raddr_s1 + {23'h0, |word_remain};
    word_remain_1 <=
      _GEN_1 ? 4'h1 << _GEN_0 : (|word_remain_1) ? word_remain_1 - 4'h1 : 4'h0;
    waddr_s1 <=
      _GEN_1
        ? {_rowReg_ext_R0_data, io_ba, io_a[8:0]}
        : waddr_s1 + {23'h0, |word_remain_1};
    di_REG <= |word_remain;
    REG <= _di_buf_din;
    r <= ~io_dqm;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    initial begin
      automatic logic [31:0] _RANDOM[0:2];
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [1:0] i = 2'h0; i < 2'h3; i += 2'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        mode = _RANDOM[2'h0][12:0];
        word_remain = _RANDOM[2'h0][16:13];
        raddr_s1 = {_RANDOM[2'h0][31:17], _RANDOM[2'h1][8:0]};
        word_remain_1 = _RANDOM[2'h1][12:9];
        waddr_s1 = {_RANDOM[2'h1][31:13], _RANDOM[2'h2][4:0]};
        di_REG = _RANDOM[2'h2][5];
        REG = _RANDOM[2'h2][21:6];
        r = _RANDOM[2'h2][23:22];
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  mem_16777216x16 mem_ext (
    .R0_addr (raddr_s1),
    .R0_en   (1'h1),
    .R0_clk  (io_clk),
    .R0_data (_mem_ext_R0_data),
    .W0_addr (waddr_s1),
    .W0_en   (|word_remain_1),
    .W0_clk  (io_clk),
    .W0_data (REG),
    .W0_mask (r)
  );
  rowReg_4x13 rowReg_ext (
    .R0_addr (io_ba),
    .R0_en   (1'h1),
    .R0_clk  (io_clk),
    .R0_data (_rowReg_ext_R0_data),
    .W0_addr (io_ba),
    .W0_en   (io_cke & cmd == 4'h3),
    .W0_clk  (io_clk),
    .W0_data (io_a)
  );
  TriStateInBuf #(
    .width(16)
  ) di_buf (
    .dio    (io_dq),
    .dout   (_mem_ext_R0_data),
    .out_en (di_REG),
    .din    (_di_buf_din)
  );
endmodule

module ysyxSoCFull(
  input  clock,
         reset,
         externalPins_uart_rx,
  output externalPins_uart_tx
);

  wire        _bitrev_miso;
  wire        _flash_miso;
  wire        _asic_spi_sck;
  wire [7:0]  _asic_spi_ss;
  wire        _asic_spi_mosi;
  wire        _asic_sdram_clk;
  wire        _asic_sdram_cke;
  wire        _asic_sdram_cs;
  wire        _asic_sdram_ras;
  wire        _asic_sdram_cas;
  wire        _asic_sdram_we;
  wire [12:0] _asic_sdram_a;
  wire [1:0]  _asic_sdram_ba;
  wire [1:0]  _asic_sdram_dqm;
  wire [15:0] _io_dq_wire;
  ysyxSoCASIC asic (
    .clock     (clock),
    .reset     (reset),
    .spi_sck   (_asic_spi_sck),
    .spi_ss    (_asic_spi_ss),
    .spi_mosi  (_asic_spi_mosi),
    .spi_miso  (_bitrev_miso & _flash_miso),
    .uart_rx   (externalPins_uart_rx),
    .uart_tx   (externalPins_uart_tx),
    .sdram_clk (_asic_sdram_clk),
    .sdram_cke (_asic_sdram_cke),
    .sdram_cs  (_asic_sdram_cs),
    .sdram_ras (_asic_sdram_ras),
    .sdram_cas (_asic_sdram_cas),
    .sdram_we  (_asic_sdram_we),
    .sdram_a   (_asic_sdram_a),
    .sdram_ba  (_asic_sdram_ba),
    .sdram_dqm (_asic_sdram_dqm),
    .sdram_dq  (_io_dq_wire)
  );
  flash flash (
    .sck  (_asic_spi_sck),
    .ss   (_asic_spi_ss[0]),
    .mosi (_asic_spi_mosi),
    .miso (_flash_miso)
  );
  bitrev bitrev (
    .sck  (_asic_spi_sck),
    .ss   (_asic_spi_ss[7]),
    .mosi (_asic_spi_mosi),
    .miso (_bitrev_miso)
  );
  sdramChisel sdram (
    .io_clk (_asic_sdram_clk),
    .io_cke (_asic_sdram_cke),
    .io_cs  (_asic_sdram_cs),
    .io_ras (_asic_sdram_ras),
    .io_cas (_asic_sdram_cas),
    .io_we  (_asic_sdram_we),
    .io_a   (_asic_sdram_a),
    .io_ba  (_asic_sdram_ba),
    .io_dqm (_asic_sdram_dqm),
    .io_dq  (_io_dq_wire)
  );
endmodule

module ysyxSoCTop(
  input clock,
        reset
);

  ysyxSoCFull dut (
    .clock                (clock),
    .reset                (reset),
    .externalPins_uart_rx (1'h0),
    .externalPins_uart_tx (/* unused */)
  );
endmodule


// ----- 8< ----- FILE "./TriStateInBuf.v" ----- 8< -----

module TriStateInBuf #(
  parameter width = 1
)(
    inout  [width-1:0] dio,
    input  [width-1:0] dout,
    input              out_en,
    output [width-1:0] din
);
  assign din = dio;
  assign dio = out_en ? dout : {width{1'bz}};
endmodule
